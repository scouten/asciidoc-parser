#![allow(unused)] // TEMPORARY while building

use std::fmt;

/// Generated by preprocessor: Sparse map of result ([`Span`]) line number to a
/// tuple of file name and line number. This allows us to work backwards from
/// the pre-processed and unified [`Span`] to the various inputs that were used
/// to construct it. Line numbers here are 1-based.
///
/// [`Span`]: crate::Span
#[derive(Clone, Default)]
pub(crate) struct SourceMap {
    data: Vec<(usize, SourceLine)>,
}

/// A `SourceLine` represents the original file and line number where a line of
/// Asciidoc text was found before [include file] and [conditional]
/// pre-processing occurred.
///
/// The first member is the file name as specified on the [include file]
/// directive. The second member is the 1-based line number.
///
/// [include file]: https://docs.asciidoctor.org/asciidoc/latest/directives/include/
/// [conditional]: https://docs.asciidoctor.org/asciidoc/latest/directives/conditionals/
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct SourceLine(pub Option<String>, pub usize);

impl SourceMap {
    pub(crate) fn append(&mut self, key: usize, value: SourceLine) {
        if let Some((last_key, _)) = self.data.last() {
            assert!(
                key > *last_key,
                "SourceMap: keys must be appended in increasing order (got {key}, last {last_key})"
            );
        }
        self.data.push((key, value));
    }

    /// Given a 1-based line number in the preprocessed source file, translate
    /// that to a file name and line number as original inputs to the parsing
    /// process.
    pub(crate) fn original_file_and_line(&self, key: usize) -> Option<SourceLine> {
        match self.data.binary_search_by_key(&key, |(k, _)| *k) {
            Ok(i) => self.data.get(i).map(|(k, v)| v.clone()),
            Err(0) => None,
            Err(i) => self
                .data
                .get(i - 1)
                .map(|(k, v)| SourceLine(v.0.clone(), v.1 + key - k)),
        }
    }
}

/*
/// Allow building from any iterator of `(usize, SourceLine)`.
impl FromIterator<(usize, SourceLine)> for SourceMap {
    fn from_iter<I: IntoIterator<Item = (usize, SourceLine)>>(iter: I) -> Self {
        let mut data: Vec<_> = iter.into_iter().collect();
        assert!(
            data.windows(2).all(|w| w[0].0 <= w[1].0),
            "SourceMap: input must be sorted by key"
        );
        Self { data }
    }
}
*/

impl fmt::Debug for SourceMap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_map()
            .entries(self.data.iter().map(|(k, v)| (k, v)))
            .finish()
    }
}
