#![allow(unused)] // TEMPORARY while building

use std::fmt;

/// Generated by preprocessor: Sparse map of result ([`Span`]) line number to a
/// tuple of file name and line number. This allows us to work backwards from
/// the pre-processed and unified [`Span`] to the various inputs that were used
/// to construct it. Line numbers here are 1-based.
///
/// [`Span`]: crate::Span
#[derive(Clone, Default)]
pub(crate) struct SourceMap {
    data: Vec<(usize, SourceLine)>,
}

/// A `SourceLine` represents the original file and line number where a line of
/// Asciidoc text was found before [include file] and [conditional]
/// pre-processing occurred.
///
/// The first member is the file name as specified on the [include file]
/// directive. The second member is the 1-based line number.
///
/// [include file]: https://docs.asciidoctor.org/asciidoc/latest/directives/include/
/// [conditional]: https://docs.asciidoctor.org/asciidoc/latest/directives/conditionals/
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct SourceLine(pub Option<String>, pub usize);

impl SourceMap {
    pub(crate) fn append(&mut self, preprocessed_line: usize, source_line: SourceLine) {
        // IMPORTANT: These _should_ be added in increasing order of
        // `preprocessed_line`, but this is not enforced.
        self.data.push((preprocessed_line, source_line));
    }

    /// Given a 1-based line number in the preprocessed source file, translate
    /// that to a file name and line number as original inputs to the parsing
    /// process.
    pub(crate) fn original_file_and_line(&self, key: usize) -> Option<SourceLine> {
        match self.data.binary_search_by_key(&key, |(k, _)| *k) {
            Ok(i) => self.data.get(i).map(|(k, v)| v.clone()),
            Err(0) => None,
            Err(i) => self
                .data
                .get(i - 1)
                .map(|(k, v)| SourceLine(v.0.clone(), v.1 + key - k)),
        }
    }
}

impl fmt::Debug for SourceMap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_map()
            .entries(self.data.iter().map(|(k, v)| (k, v)))
            .finish()
    }
}
